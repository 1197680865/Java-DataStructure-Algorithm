package niuke;

/**
 * 二进制中1的个数
 * 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
 * 输入 10，返回 2
 * 细节： 1.位运算 &按位与 ；>>二进制位向右移动一位，最高位补0；
 * 2.原码 反码 补码
 *   正数的原码、反码、补码是其本身；
 *   负数的原码：最高位为1，存储符号。假设使用一个字节存储整数，整数-10的原码是：1000 1010
 *   负数的反码：是负数的原码按位取反（0变1,1变0），符号位不变。假设使用一个字节存储整数，整数-10的反码是：1111 0101
 *   负数的补码：是负数的反码加1。　假设使用一个字节存储整数，整数-10的补码是：1111 0110（强调：这一串是-10这个整数在计算机中存储形式）
 */
public class JZ11_BinaryBit1 {
    //使用数学工具类
    //(int)Math.pow(2,3); //2^3!=8  ^为异或运算，位相同为0，不同为1
    public int NumberOf1(int n) {
        //方法1 位运算，逐位进行 0X01同n右移位作比较，
        //注意：本方法无法比较负数
        /*
        int ans = 0;
        while(n>0){
            if((n & 1)==1 ){ //& 位运算-与 ，位相同则位为1： 1为2进制的1，实际上为0x000...0001，也可写为0x01
                ans++;
            }
            n = n>>1; //>>位运算，二进制结果右移一位：如果val的二进制是110，则操作之后会变成011,也就是舍去最低位，然后最高位补0
        }
        return ans;
        */
        //方法2 位运算，逐位进行 0X01左移位同n作比较，
        //注意：本方法可以比较负数
        int ans = 0;
        int mask =0x01;
        while(mask!=0){
            if((n & mask)==mask) ans++;
            mask = mask<<1; //<<位运算，二进制结果左移一位：
        }
        return ans;
    }


    public static void main(String[] args) {
        System.out.println( 4 & 1 ); //0 100&001
        System.out.println( 5 & 1 ); //1 101&001
        System.out.println( 6 & 3 ); //2 110&011
        System.out.println( (5 & 1) ==1 ); //true
    }
}
